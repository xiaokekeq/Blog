import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as n,c as s,b as t}from"./app-9VNL1xHc.js";const e="/Blog/assets/image-20240430112345571-72kIsKqn.png",p={},o=t('<h1 id="mybatis" tabindex="-1"><a class="header-anchor" href="#mybatis"><span>Mybatis</span></a></h1><p>如果<mark>在application.yml中配置了configuration就不能在resources中写mybatis-config.xml文件了</mark>他们两个<mark>会冲突</mark>，如果有其他配置文件要写就去写一个配置类进行对mybatis配置</p><h1 id="springboot" tabindex="-1"><a class="header-anchor" href="#springboot"><span>SpringBoot</span></a></h1><p>继承spring-boot-starter-parent其实也算是继承自spring-boot-dependencies,我们点开spring-boot-starter-parent,可以看到parent其实也是继承dependencies,parent里面就增加了一些插件,然后指定了maven编译版本:</p><figure><img src="'+e+`" alt="image-20240430112345571" tabindex="0" loading="lazy"><figcaption>image-20240430112345571</figcaption></figure><p>RestFul风格的请求，从request中获取参数：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Map</span> serviceName <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token punctuation">)</span> request<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token class-name">HandlerMapping</span><span class="token punctuation">.</span><span class="token constant">URI_TEMPLATE_VARIABLES_ATTRIBUTE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>serviceName<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;serviceName&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> serviceName<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;serviceName&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="思路" tabindex="-1"><a class="header-anchor" href="#思路"><span><strong>思路：</strong></span></a></h2><h3 id="大型项目配置" tabindex="-1"><a class="header-anchor" href="#大型项目配置"><span>大型项目配置：</span></a></h3><p>1、导入依赖</p><p>2、编写配置文件</p><p>3、开启这个功能 @EnableXXXX</p><p>4、配置类</p><h1 id="微服务与分布式区别" tabindex="-1"><a class="header-anchor" href="#微服务与分布式区别"><span>微服务与分布式区别</span></a></h1><p>**分布式：**将一个项目中的各个服务分散部署在不同的机器上的，一个服务可能负责几个功能，是一种面向服务的架构（SOA）。</p><p>**微服务：**微服务是一种架构风格，微服务就是很小的一个服务，服务即应用，亦即我们俗称的一个项目。相较于以往常见的单体应用，微服务的核心思想是将一个大项目的各个业务模块甚至某个单一功能抽离出来，作为一个单独的完整项目，单独部署，该应用只需要为该大项目或者其他项目的业务模块提供服务即可。缺点：开发成本高，众多服务出错的处理（容错），分布式事务的问题</p><p><strong>分布式和微服务的区别总结</strong> 从分布式和微服务的概念来看，都是对一个项目系统进行了拆分，一个是在部署层面，一个是在架构设计层面。但是微服务相较于分布式来说，细粒度更小，服务间的耦合度更低，并且可以说微服务一定是分服务分开部署的，所以其实微服务是基于分布式的，更像是对分布式系统的一种优化，因此很多时候微服务架构也被称为是分布式的架构，区别于分布式系统。</p><p>并且可以预见的是，分布式系统最后都会向微服务架构演化，这是一种趋势， 不过服务微服务化后带来的挑战也是显而易见的，例如服务粒度小，数量大，后期运维将会很难等问题。</p>`,18),c=[o];function i(r,l){return n(),s("div",null,c)}const k=a(p,[["render",i],["__file","常见错误.html.vue"]]);export{k as default};
